import {
  __commonJS,
  __toESM
} from "./chunk-ACCAMVX6.js";

// node_modules/isomorphic-form-data/lib/browser.js
var require_browser = __commonJS({
  "node_modules/isomorphic-form-data/lib/browser.js"(exports, module) {
    module.exports = window.FormData;
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var global = typeof self !== "undefined" ? self : exports;
    var __self__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = global.DOMException;
      }
      F.prototype = global;
      return new F();
    }();
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch2;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/appwrite/dist/esm/sdk.js
var import_isomorphic_form_data = __toESM(require_browser(), 1);
var import_cross_fetch = __toESM(require_browser_ponyfill(), 1);
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var Service = class {
  constructor(client) {
    this.client = client;
  }
  static flatten(data, prefix = "") {
    let output = {};
    for (const key in data) {
      let value = data[key];
      let finalKey = prefix ? `${prefix}[${key}]` : key;
      if (Array.isArray(value)) {
        output = Object.assign(output, this.flatten(value, finalKey));
      } else {
        output[finalKey] = value;
      }
    }
    return output;
  }
};
Service.CHUNK_SIZE = 5 * 1024 * 1024;
var Query = class {
};
Query.equal = (attribute, value) => Query.addQuery(attribute, "equal", value);
Query.notEqual = (attribute, value) => Query.addQuery(attribute, "notEqual", value);
Query.lesser = (attribute, value) => Query.addQuery(attribute, "lesser", value);
Query.lesserEqual = (attribute, value) => Query.addQuery(attribute, "lesserEqual", value);
Query.greater = (attribute, value) => Query.addQuery(attribute, "greater", value);
Query.greaterEqual = (attribute, value) => Query.addQuery(attribute, "greaterEqual", value);
Query.search = (attribute, value) => Query.addQuery(attribute, "search", value);
Query.addQuery = (attribute, oper, value) => value instanceof Array ? `${attribute}.${oper}(${value.map((v) => Query.parseValues(v)).join(",")})` : `${attribute}.${oper}(${Query.parseValues(value)})`;
Query.parseValues = (value) => typeof value === "string" || value instanceof String ? `"${value}"` : `${value}`;
var AppwriteException = class extends Error {
  constructor(message, code = 0, type = "", response = "") {
    super(message);
    this.name = "AppwriteException";
    this.message = message;
    this.code = code;
    this.type = type;
    this.response = response;
  }
};
var Client = class {
  constructor() {
    this.config = {
      endpoint: "https://HOSTNAME/v1",
      endpointRealtime: "",
      project: "",
      jwt: "",
      locale: ""
    };
    this.headers = {
      "x-sdk-version": "appwrite:web:9.0.1",
      "X-Appwrite-Response-Format": "0.15.0"
    };
    this.realtime = {
      socket: void 0,
      timeout: void 0,
      url: "",
      channels: /* @__PURE__ */ new Set(),
      subscriptions: /* @__PURE__ */ new Map(),
      subscriptionsCounter: 0,
      reconnect: true,
      reconnectAttempts: 0,
      lastMessage: void 0,
      connect: () => {
        clearTimeout(this.realtime.timeout);
        this.realtime.timeout = window === null || window === void 0 ? void 0 : window.setTimeout(() => {
          this.realtime.createSocket();
        }, 50);
      },
      getTimeout: () => {
        switch (true) {
          case this.realtime.reconnectAttempts < 5:
            return 1e3;
          case this.realtime.reconnectAttempts < 15:
            return 5e3;
          case this.realtime.reconnectAttempts < 100:
            return 1e4;
          default:
            return 6e4;
        }
      },
      createSocket: () => {
        var _a, _b;
        if (this.realtime.channels.size < 1)
          return;
        const channels = new URLSearchParams();
        channels.set("project", this.config.project);
        this.realtime.channels.forEach((channel) => {
          channels.append("channels[]", channel);
        });
        const url = this.config.endpointRealtime + "/realtime?" + channels.toString();
        if (url !== this.realtime.url || !this.realtime.socket || ((_a = this.realtime.socket) === null || _a === void 0 ? void 0 : _a.readyState) > WebSocket.OPEN) {
          if (this.realtime.socket && ((_b = this.realtime.socket) === null || _b === void 0 ? void 0 : _b.readyState) < WebSocket.CLOSING) {
            this.realtime.reconnect = false;
            this.realtime.socket.close();
          }
          this.realtime.url = url;
          this.realtime.socket = new WebSocket(url);
          this.realtime.socket.addEventListener("message", this.realtime.onMessage);
          this.realtime.socket.addEventListener("open", (_event) => {
            this.realtime.reconnectAttempts = 0;
          });
          this.realtime.socket.addEventListener("close", (event) => {
            var _a2, _b2, _c;
            if (!this.realtime.reconnect || ((_b2 = (_a2 = this.realtime) === null || _a2 === void 0 ? void 0 : _a2.lastMessage) === null || _b2 === void 0 ? void 0 : _b2.type) === "error" && ((_c = this.realtime) === null || _c === void 0 ? void 0 : _c.lastMessage.data).code === 1008) {
              this.realtime.reconnect = true;
              return;
            }
            const timeout = this.realtime.getTimeout();
            console.error(`Realtime got disconnected. Reconnect will be attempted in ${timeout / 1e3} seconds.`, event.reason);
            setTimeout(() => {
              this.realtime.reconnectAttempts++;
              this.realtime.createSocket();
            }, timeout);
          });
        }
      },
      onMessage: (event) => {
        var _a, _b;
        try {
          const message = JSON.parse(event.data);
          this.realtime.lastMessage = message;
          switch (message.type) {
            case "connected":
              const cookie = JSON.parse((_a = window.localStorage.getItem("cookieFallback")) !== null && _a !== void 0 ? _a : "{}");
              const session = cookie === null || cookie === void 0 ? void 0 : cookie[`a_session_${this.config.project}`];
              const messageData = message.data;
              if (session && !messageData.user) {
                (_b = this.realtime.socket) === null || _b === void 0 ? void 0 : _b.send(JSON.stringify({
                  type: "authentication",
                  data: {
                    session
                  }
                }));
              }
              break;
            case "event":
              let data = message.data;
              if (data === null || data === void 0 ? void 0 : data.channels) {
                const isSubscribed = data.channels.some((channel) => this.realtime.channels.has(channel));
                if (!isSubscribed)
                  return;
                this.realtime.subscriptions.forEach((subscription) => {
                  if (data.channels.some((channel) => subscription.channels.includes(channel))) {
                    setTimeout(() => subscription.callback(data));
                  }
                });
              }
              break;
            case "error":
              throw message.data;
            default:
              break;
          }
        } catch (e) {
          console.error(e);
        }
      },
      cleanUp: (channels) => {
        this.realtime.channels.forEach((channel) => {
          if (channels.includes(channel)) {
            let found = Array.from(this.realtime.subscriptions).some(([_key, subscription]) => {
              return subscription.channels.includes(channel);
            });
            if (!found) {
              this.realtime.channels.delete(channel);
            }
          }
        });
      }
    };
  }
  setEndpoint(endpoint) {
    this.config.endpoint = endpoint;
    this.config.endpointRealtime = this.config.endpointRealtime || this.config.endpoint.replace("https://", "wss://").replace("http://", "ws://");
    return this;
  }
  setEndpointRealtime(endpointRealtime) {
    this.config.endpointRealtime = endpointRealtime;
    return this;
  }
  setProject(value) {
    this.headers["X-Appwrite-Project"] = value;
    this.config.project = value;
    return this;
  }
  setJWT(value) {
    this.headers["X-Appwrite-JWT"] = value;
    this.config.jwt = value;
    return this;
  }
  setLocale(value) {
    this.headers["X-Appwrite-Locale"] = value;
    this.config.locale = value;
    return this;
  }
  subscribe(channels, callback) {
    let channelArray = typeof channels === "string" ? [channels] : channels;
    channelArray.forEach((channel) => this.realtime.channels.add(channel));
    const counter = this.realtime.subscriptionsCounter++;
    this.realtime.subscriptions.set(counter, {
      channels: channelArray,
      callback
    });
    this.realtime.connect();
    return () => {
      this.realtime.subscriptions.delete(counter);
      this.realtime.cleanUp(channelArray);
      this.realtime.connect();
    };
  }
  call(method, url, headers = {}, params = {}) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
      method = method.toUpperCase();
      headers = Object.assign({}, this.headers, headers);
      let options = {
        method,
        headers,
        credentials: "include"
      };
      if (typeof window !== "undefined" && window.localStorage) {
        headers["X-Fallback-Cookies"] = (_a = window.localStorage.getItem("cookieFallback")) !== null && _a !== void 0 ? _a : "";
      }
      if (method === "GET") {
        for (const [key, value] of Object.entries(Service.flatten(params))) {
          url.searchParams.append(key, value);
        }
      } else {
        switch (headers["content-type"]) {
          case "application/json":
            options.body = JSON.stringify(params);
            break;
          case "multipart/form-data":
            let formData = new FormData();
            for (const key in params) {
              if (Array.isArray(params[key])) {
                params[key].forEach((value) => {
                  formData.append(key + "[]", value);
                });
              } else {
                formData.append(key, params[key]);
              }
            }
            options.body = formData;
            delete headers["content-type"];
            break;
        }
      }
      try {
        let data = null;
        const response = yield (0, import_cross_fetch.fetch)(url.toString(), options);
        if ((_b = response.headers.get("content-type")) === null || _b === void 0 ? void 0 : _b.includes("application/json")) {
          data = yield response.json();
        } else {
          data = {
            message: yield response.text()
          };
        }
        if (400 <= response.status) {
          throw new AppwriteException(data === null || data === void 0 ? void 0 : data.message, response.status, data === null || data === void 0 ? void 0 : data.type, data);
        }
        const cookieFallback = response.headers.get("X-Fallback-Cookies");
        if (typeof window !== "undefined" && window.localStorage && cookieFallback) {
          window.console.warn("Appwrite is using localStorage for session management. Increase your security by adding a custom domain as your API endpoint.");
          window.localStorage.setItem("cookieFallback", cookieFallback);
        }
        return data;
      } catch (e) {
        if (e instanceof AppwriteException) {
          throw e;
        }
        throw new AppwriteException(e.message);
      }
    });
  }
};
var Account = class extends Service {
  get() {
    return __awaiter(this, void 0, void 0, function* () {
      let path = "/account";
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  create(userId, email, password, name) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof userId === "undefined") {
        throw new AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new AppwriteException('Missing required parameter: "password"');
      }
      let path = "/account";
      let payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("post", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  updateEmail(email, password) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof email === "undefined") {
        throw new AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new AppwriteException('Missing required parameter: "password"');
      }
      let path = "/account/email";
      let payload = {};
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("patch", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  createJWT() {
    return __awaiter(this, void 0, void 0, function* () {
      let path = "/account/jwt";
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("post", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  getLogs(limit, offset) {
    return __awaiter(this, void 0, void 0, function* () {
      let path = "/account/logs";
      let payload = {};
      if (typeof limit !== "undefined") {
        payload["limit"] = limit;
      }
      if (typeof offset !== "undefined") {
        payload["offset"] = offset;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  updateName(name) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof name === "undefined") {
        throw new AppwriteException('Missing required parameter: "name"');
      }
      let path = "/account/name";
      let payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("patch", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  updatePassword(password, oldPassword) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof password === "undefined") {
        throw new AppwriteException('Missing required parameter: "password"');
      }
      let path = "/account/password";
      let payload = {};
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof oldPassword !== "undefined") {
        payload["oldPassword"] = oldPassword;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("patch", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  updatePhone(number, password) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof number === "undefined") {
        throw new AppwriteException('Missing required parameter: "number"');
      }
      if (typeof password === "undefined") {
        throw new AppwriteException('Missing required parameter: "password"');
      }
      let path = "/account/phone";
      let payload = {};
      if (typeof number !== "undefined") {
        payload["number"] = number;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("patch", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  getPrefs() {
    return __awaiter(this, void 0, void 0, function* () {
      let path = "/account/prefs";
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  updatePrefs(prefs) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof prefs === "undefined") {
        throw new AppwriteException('Missing required parameter: "prefs"');
      }
      let path = "/account/prefs";
      let payload = {};
      if (typeof prefs !== "undefined") {
        payload["prefs"] = prefs;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("patch", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  createRecovery(email, url) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof email === "undefined") {
        throw new AppwriteException('Missing required parameter: "email"');
      }
      if (typeof url === "undefined") {
        throw new AppwriteException('Missing required parameter: "url"');
      }
      let path = "/account/recovery";
      let payload = {};
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof url !== "undefined") {
        payload["url"] = url;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("post", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  updateRecovery(userId, secret, password, passwordAgain) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof userId === "undefined") {
        throw new AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new AppwriteException('Missing required parameter: "secret"');
      }
      if (typeof password === "undefined") {
        throw new AppwriteException('Missing required parameter: "password"');
      }
      if (typeof passwordAgain === "undefined") {
        throw new AppwriteException('Missing required parameter: "passwordAgain"');
      }
      let path = "/account/recovery";
      let payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof passwordAgain !== "undefined") {
        payload["passwordAgain"] = passwordAgain;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("put", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  getSessions() {
    return __awaiter(this, void 0, void 0, function* () {
      let path = "/account/sessions";
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  deleteSessions() {
    return __awaiter(this, void 0, void 0, function* () {
      let path = "/account/sessions";
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("delete", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  createAnonymousSession() {
    return __awaiter(this, void 0, void 0, function* () {
      let path = "/account/sessions/anonymous";
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("post", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  createEmailSession(email, password) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof email === "undefined") {
        throw new AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new AppwriteException('Missing required parameter: "password"');
      }
      let path = "/account/sessions/email";
      let payload = {};
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("post", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  createMagicURLSession(userId, email, url) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof userId === "undefined") {
        throw new AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new AppwriteException('Missing required parameter: "email"');
      }
      let path = "/account/sessions/magic-url";
      let payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof url !== "undefined") {
        payload["url"] = url;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("post", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  updateMagicURLSession(userId, secret) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof userId === "undefined") {
        throw new AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new AppwriteException('Missing required parameter: "secret"');
      }
      let path = "/account/sessions/magic-url";
      let payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("put", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  createOAuth2Session(provider, success, failure, scopes) {
    if (typeof provider === "undefined") {
      throw new AppwriteException('Missing required parameter: "provider"');
    }
    let path = "/account/sessions/oauth2/{provider}".replace("{provider}", provider);
    let payload = {};
    if (typeof success !== "undefined") {
      payload["success"] = success;
    }
    if (typeof failure !== "undefined") {
      payload["failure"] = failure;
    }
    if (typeof scopes !== "undefined") {
      payload["scopes"] = scopes;
    }
    const uri = new URL(this.client.config.endpoint + path);
    payload["project"] = this.client.config.project;
    for (const [key, value] of Object.entries(Service.flatten(payload))) {
      uri.searchParams.append(key, value);
    }
    if (typeof window !== "undefined" && (window === null || window === void 0 ? void 0 : window.location)) {
      window.location.href = uri.toString();
    } else {
      return uri;
    }
  }
  createPhoneSession(userId, number) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof userId === "undefined") {
        throw new AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof number === "undefined") {
        throw new AppwriteException('Missing required parameter: "number"');
      }
      let path = "/account/sessions/phone";
      let payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof number !== "undefined") {
        payload["number"] = number;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("post", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  updatePhoneSession(userId, secret) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof userId === "undefined") {
        throw new AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new AppwriteException('Missing required parameter: "secret"');
      }
      let path = "/account/sessions/phone";
      let payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("put", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  getSession(sessionId) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof sessionId === "undefined") {
        throw new AppwriteException('Missing required parameter: "sessionId"');
      }
      let path = "/account/sessions/{sessionId}".replace("{sessionId}", sessionId);
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  updateSession(sessionId) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof sessionId === "undefined") {
        throw new AppwriteException('Missing required parameter: "sessionId"');
      }
      let path = "/account/sessions/{sessionId}".replace("{sessionId}", sessionId);
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("patch", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  deleteSession(sessionId) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof sessionId === "undefined") {
        throw new AppwriteException('Missing required parameter: "sessionId"');
      }
      let path = "/account/sessions/{sessionId}".replace("{sessionId}", sessionId);
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("delete", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  updateStatus() {
    return __awaiter(this, void 0, void 0, function* () {
      let path = "/account/status";
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("patch", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  createVerification(url) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof url === "undefined") {
        throw new AppwriteException('Missing required parameter: "url"');
      }
      let path = "/account/verification";
      let payload = {};
      if (typeof url !== "undefined") {
        payload["url"] = url;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("post", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  updateVerification(userId, secret) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof userId === "undefined") {
        throw new AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new AppwriteException('Missing required parameter: "secret"');
      }
      let path = "/account/verification";
      let payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("put", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  createPhoneVerification() {
    return __awaiter(this, void 0, void 0, function* () {
      let path = "/account/verification/phone";
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("post", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  updatePhoneVerification(userId, secret) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof userId === "undefined") {
        throw new AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new AppwriteException('Missing required parameter: "secret"');
      }
      let path = "/account/verification/phone";
      let payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("put", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
};
var Avatars = class extends Service {
  getBrowser(code, width, height, quality) {
    if (typeof code === "undefined") {
      throw new AppwriteException('Missing required parameter: "code"');
    }
    let path = "/avatars/browsers/{code}".replace("{code}", code);
    let payload = {};
    if (typeof width !== "undefined") {
      payload["width"] = width;
    }
    if (typeof height !== "undefined") {
      payload["height"] = height;
    }
    if (typeof quality !== "undefined") {
      payload["quality"] = quality;
    }
    const uri = new URL(this.client.config.endpoint + path);
    payload["project"] = this.client.config.project;
    for (const [key, value] of Object.entries(Service.flatten(payload))) {
      uri.searchParams.append(key, value);
    }
    return uri;
  }
  getCreditCard(code, width, height, quality) {
    if (typeof code === "undefined") {
      throw new AppwriteException('Missing required parameter: "code"');
    }
    let path = "/avatars/credit-cards/{code}".replace("{code}", code);
    let payload = {};
    if (typeof width !== "undefined") {
      payload["width"] = width;
    }
    if (typeof height !== "undefined") {
      payload["height"] = height;
    }
    if (typeof quality !== "undefined") {
      payload["quality"] = quality;
    }
    const uri = new URL(this.client.config.endpoint + path);
    payload["project"] = this.client.config.project;
    for (const [key, value] of Object.entries(Service.flatten(payload))) {
      uri.searchParams.append(key, value);
    }
    return uri;
  }
  getFavicon(url) {
    if (typeof url === "undefined") {
      throw new AppwriteException('Missing required parameter: "url"');
    }
    let path = "/avatars/favicon";
    let payload = {};
    if (typeof url !== "undefined") {
      payload["url"] = url;
    }
    const uri = new URL(this.client.config.endpoint + path);
    payload["project"] = this.client.config.project;
    for (const [key, value] of Object.entries(Service.flatten(payload))) {
      uri.searchParams.append(key, value);
    }
    return uri;
  }
  getFlag(code, width, height, quality) {
    if (typeof code === "undefined") {
      throw new AppwriteException('Missing required parameter: "code"');
    }
    let path = "/avatars/flags/{code}".replace("{code}", code);
    let payload = {};
    if (typeof width !== "undefined") {
      payload["width"] = width;
    }
    if (typeof height !== "undefined") {
      payload["height"] = height;
    }
    if (typeof quality !== "undefined") {
      payload["quality"] = quality;
    }
    const uri = new URL(this.client.config.endpoint + path);
    payload["project"] = this.client.config.project;
    for (const [key, value] of Object.entries(Service.flatten(payload))) {
      uri.searchParams.append(key, value);
    }
    return uri;
  }
  getImage(url, width, height) {
    if (typeof url === "undefined") {
      throw new AppwriteException('Missing required parameter: "url"');
    }
    let path = "/avatars/image";
    let payload = {};
    if (typeof url !== "undefined") {
      payload["url"] = url;
    }
    if (typeof width !== "undefined") {
      payload["width"] = width;
    }
    if (typeof height !== "undefined") {
      payload["height"] = height;
    }
    const uri = new URL(this.client.config.endpoint + path);
    payload["project"] = this.client.config.project;
    for (const [key, value] of Object.entries(Service.flatten(payload))) {
      uri.searchParams.append(key, value);
    }
    return uri;
  }
  getInitials(name, width, height, color, background) {
    let path = "/avatars/initials";
    let payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof width !== "undefined") {
      payload["width"] = width;
    }
    if (typeof height !== "undefined") {
      payload["height"] = height;
    }
    if (typeof color !== "undefined") {
      payload["color"] = color;
    }
    if (typeof background !== "undefined") {
      payload["background"] = background;
    }
    const uri = new URL(this.client.config.endpoint + path);
    payload["project"] = this.client.config.project;
    for (const [key, value] of Object.entries(Service.flatten(payload))) {
      uri.searchParams.append(key, value);
    }
    return uri;
  }
  getQR(text, size, margin, download) {
    if (typeof text === "undefined") {
      throw new AppwriteException('Missing required parameter: "text"');
    }
    let path = "/avatars/qr";
    let payload = {};
    if (typeof text !== "undefined") {
      payload["text"] = text;
    }
    if (typeof size !== "undefined") {
      payload["size"] = size;
    }
    if (typeof margin !== "undefined") {
      payload["margin"] = margin;
    }
    if (typeof download !== "undefined") {
      payload["download"] = download;
    }
    const uri = new URL(this.client.config.endpoint + path);
    payload["project"] = this.client.config.project;
    for (const [key, value] of Object.entries(Service.flatten(payload))) {
      uri.searchParams.append(key, value);
    }
    return uri;
  }
};
var Databases = class extends Service {
  constructor(client, databaseId) {
    super(client);
    this.databaseId = databaseId;
  }
  setDatabaseId(databaseId) {
    this.databaseId = databaseId;
  }
  getDatabaseId() {
    return this.databaseId;
  }
  listDocuments(collectionId, queries, limit, offset, cursor, cursorDirection, orderAttributes, orderTypes) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof collectionId === "undefined") {
        throw new AppwriteException('Missing required parameter: "collectionId"');
      }
      let path = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", this.databaseId).replace("{collectionId}", collectionId);
      let payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof limit !== "undefined") {
        payload["limit"] = limit;
      }
      if (typeof offset !== "undefined") {
        payload["offset"] = offset;
      }
      if (typeof cursor !== "undefined") {
        payload["cursor"] = cursor;
      }
      if (typeof cursorDirection !== "undefined") {
        payload["cursorDirection"] = cursorDirection;
      }
      if (typeof orderAttributes !== "undefined") {
        payload["orderAttributes"] = orderAttributes;
      }
      if (typeof orderTypes !== "undefined") {
        payload["orderTypes"] = orderTypes;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  createDocument(collectionId, documentId, data, read, write) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof collectionId === "undefined") {
        throw new AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof documentId === "undefined") {
        throw new AppwriteException('Missing required parameter: "documentId"');
      }
      if (typeof data === "undefined") {
        throw new AppwriteException('Missing required parameter: "data"');
      }
      let path = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", this.databaseId).replace("{collectionId}", collectionId);
      let payload = {};
      if (typeof documentId !== "undefined") {
        payload["documentId"] = documentId;
      }
      if (typeof data !== "undefined") {
        payload["data"] = data;
      }
      if (typeof read !== "undefined") {
        payload["read"] = read;
      }
      if (typeof write !== "undefined") {
        payload["write"] = write;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("post", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  getDocument(collectionId, documentId) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof collectionId === "undefined") {
        throw new AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof documentId === "undefined") {
        throw new AppwriteException('Missing required parameter: "documentId"');
      }
      let path = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}", this.databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId);
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  updateDocument(collectionId, documentId, data, read, write) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof collectionId === "undefined") {
        throw new AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof documentId === "undefined") {
        throw new AppwriteException('Missing required parameter: "documentId"');
      }
      let path = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}", this.databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId);
      let payload = {};
      if (typeof data !== "undefined") {
        payload["data"] = data;
      }
      if (typeof read !== "undefined") {
        payload["read"] = read;
      }
      if (typeof write !== "undefined") {
        payload["write"] = write;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("patch", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  deleteDocument(collectionId, documentId) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof collectionId === "undefined") {
        throw new AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof documentId === "undefined") {
        throw new AppwriteException('Missing required parameter: "documentId"');
      }
      let path = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}", this.databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId);
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("delete", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
};
var Functions = class extends Service {
  retryBuild(functionId, deploymentId, buildId) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof functionId === "undefined") {
        throw new AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new AppwriteException('Missing required parameter: "deploymentId"');
      }
      if (typeof buildId === "undefined") {
        throw new AppwriteException('Missing required parameter: "buildId"');
      }
      let path = "/functions/{functionId}/deployments/{deploymentId}/builds/{buildId}".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId).replace("{buildId}", buildId);
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("post", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  listExecutions(functionId, limit, offset, search, cursor, cursorDirection) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof functionId === "undefined") {
        throw new AppwriteException('Missing required parameter: "functionId"');
      }
      let path = "/functions/{functionId}/executions".replace("{functionId}", functionId);
      let payload = {};
      if (typeof limit !== "undefined") {
        payload["limit"] = limit;
      }
      if (typeof offset !== "undefined") {
        payload["offset"] = offset;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof cursor !== "undefined") {
        payload["cursor"] = cursor;
      }
      if (typeof cursorDirection !== "undefined") {
        payload["cursorDirection"] = cursorDirection;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  createExecution(functionId, data, async) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof functionId === "undefined") {
        throw new AppwriteException('Missing required parameter: "functionId"');
      }
      let path = "/functions/{functionId}/executions".replace("{functionId}", functionId);
      let payload = {};
      if (typeof data !== "undefined") {
        payload["data"] = data;
      }
      if (typeof async !== "undefined") {
        payload["async"] = async;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("post", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  getExecution(functionId, executionId) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof functionId === "undefined") {
        throw new AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof executionId === "undefined") {
        throw new AppwriteException('Missing required parameter: "executionId"');
      }
      let path = "/functions/{functionId}/executions/{executionId}".replace("{functionId}", functionId).replace("{executionId}", executionId);
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
};
var Locale = class extends Service {
  get() {
    return __awaiter(this, void 0, void 0, function* () {
      let path = "/locale";
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  getContinents() {
    return __awaiter(this, void 0, void 0, function* () {
      let path = "/locale/continents";
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  getCountries() {
    return __awaiter(this, void 0, void 0, function* () {
      let path = "/locale/countries";
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  getCountriesEU() {
    return __awaiter(this, void 0, void 0, function* () {
      let path = "/locale/countries/eu";
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  getCountriesPhones() {
    return __awaiter(this, void 0, void 0, function* () {
      let path = "/locale/countries/phones";
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  getCurrencies() {
    return __awaiter(this, void 0, void 0, function* () {
      let path = "/locale/currencies";
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  getLanguages() {
    return __awaiter(this, void 0, void 0, function* () {
      let path = "/locale/languages";
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
};
var Storage = class extends Service {
  listFiles(bucketId, search, limit, offset, cursor, cursorDirection, orderType) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof bucketId === "undefined") {
        throw new AppwriteException('Missing required parameter: "bucketId"');
      }
      let path = "/storage/buckets/{bucketId}/files".replace("{bucketId}", bucketId);
      let payload = {};
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof limit !== "undefined") {
        payload["limit"] = limit;
      }
      if (typeof offset !== "undefined") {
        payload["offset"] = offset;
      }
      if (typeof cursor !== "undefined") {
        payload["cursor"] = cursor;
      }
      if (typeof cursorDirection !== "undefined") {
        payload["cursorDirection"] = cursorDirection;
      }
      if (typeof orderType !== "undefined") {
        payload["orderType"] = orderType;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  createFile(bucketId, fileId, file, read, write, onProgress = (progress) => {
  }) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof bucketId === "undefined") {
        throw new AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new AppwriteException('Missing required parameter: "fileId"');
      }
      if (typeof file === "undefined") {
        throw new AppwriteException('Missing required parameter: "file"');
      }
      let path = "/storage/buckets/{bucketId}/files".replace("{bucketId}", bucketId);
      let payload = {};
      if (typeof fileId !== "undefined") {
        payload["fileId"] = fileId;
      }
      if (typeof file !== "undefined") {
        payload["file"] = file;
      }
      if (typeof read !== "undefined") {
        payload["read"] = read;
      }
      if (typeof write !== "undefined") {
        payload["write"] = write;
      }
      const uri = new URL(this.client.config.endpoint + path);
      if (!(file instanceof File)) {
        throw new AppwriteException('Parameter "file" has to be a File.');
      }
      const size = file.size;
      if (size <= Service.CHUNK_SIZE) {
        return yield this.client.call("post", uri, {
          "content-type": "multipart/form-data"
        }, payload);
      }
      let id = void 0;
      let response = void 0;
      const headers = {
        "content-type": "multipart/form-data"
      };
      let counter = 0;
      const totalCounters = Math.ceil(size / Service.CHUNK_SIZE);
      if (fileId != "unique()") {
        try {
          response = yield this.client.call("GET", new URL(this.client.config.endpoint + path + "/" + fileId), headers);
          counter = response.chunksUploaded;
        } catch (e) {
        }
      }
      for (counter; counter < totalCounters; counter++) {
        const start = counter * Service.CHUNK_SIZE;
        const end = Math.min(counter * Service.CHUNK_SIZE + Service.CHUNK_SIZE - 1, size);
        headers["content-range"] = "bytes " + start + "-" + end + "/" + size;
        if (id) {
          headers["x-appwrite-id"] = id;
        }
        const stream = file.slice(start, end + 1);
        payload["file"] = new File([stream], file.name);
        response = yield this.client.call("post", uri, headers, payload);
        if (!id) {
          id = response["$id"];
        }
        if (onProgress) {
          onProgress({
            $id: response.$id,
            progress: Math.min((counter + 1) * Service.CHUNK_SIZE - 1, size) / size * 100,
            sizeUploaded: end,
            chunksTotal: response.chunksTotal,
            chunksUploaded: response.chunksUploaded
          });
        }
      }
      return response;
    });
  }
  getFile(bucketId, fileId) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof bucketId === "undefined") {
        throw new AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new AppwriteException('Missing required parameter: "fileId"');
      }
      let path = "/storage/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  updateFile(bucketId, fileId, read, write) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof bucketId === "undefined") {
        throw new AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new AppwriteException('Missing required parameter: "fileId"');
      }
      let path = "/storage/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
      let payload = {};
      if (typeof read !== "undefined") {
        payload["read"] = read;
      }
      if (typeof write !== "undefined") {
        payload["write"] = write;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("put", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  deleteFile(bucketId, fileId) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof bucketId === "undefined") {
        throw new AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new AppwriteException('Missing required parameter: "fileId"');
      }
      let path = "/storage/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("delete", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  getFileDownload(bucketId, fileId) {
    if (typeof bucketId === "undefined") {
      throw new AppwriteException('Missing required parameter: "bucketId"');
    }
    if (typeof fileId === "undefined") {
      throw new AppwriteException('Missing required parameter: "fileId"');
    }
    let path = "/storage/buckets/{bucketId}/files/{fileId}/download".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
    let payload = {};
    const uri = new URL(this.client.config.endpoint + path);
    payload["project"] = this.client.config.project;
    for (const [key, value] of Object.entries(Service.flatten(payload))) {
      uri.searchParams.append(key, value);
    }
    return uri;
  }
  getFilePreview(bucketId, fileId, width, height, gravity, quality, borderWidth, borderColor, borderRadius, opacity, rotation, background, output) {
    if (typeof bucketId === "undefined") {
      throw new AppwriteException('Missing required parameter: "bucketId"');
    }
    if (typeof fileId === "undefined") {
      throw new AppwriteException('Missing required parameter: "fileId"');
    }
    let path = "/storage/buckets/{bucketId}/files/{fileId}/preview".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
    let payload = {};
    if (typeof width !== "undefined") {
      payload["width"] = width;
    }
    if (typeof height !== "undefined") {
      payload["height"] = height;
    }
    if (typeof gravity !== "undefined") {
      payload["gravity"] = gravity;
    }
    if (typeof quality !== "undefined") {
      payload["quality"] = quality;
    }
    if (typeof borderWidth !== "undefined") {
      payload["borderWidth"] = borderWidth;
    }
    if (typeof borderColor !== "undefined") {
      payload["borderColor"] = borderColor;
    }
    if (typeof borderRadius !== "undefined") {
      payload["borderRadius"] = borderRadius;
    }
    if (typeof opacity !== "undefined") {
      payload["opacity"] = opacity;
    }
    if (typeof rotation !== "undefined") {
      payload["rotation"] = rotation;
    }
    if (typeof background !== "undefined") {
      payload["background"] = background;
    }
    if (typeof output !== "undefined") {
      payload["output"] = output;
    }
    const uri = new URL(this.client.config.endpoint + path);
    payload["project"] = this.client.config.project;
    for (const [key, value] of Object.entries(Service.flatten(payload))) {
      uri.searchParams.append(key, value);
    }
    return uri;
  }
  getFileView(bucketId, fileId) {
    if (typeof bucketId === "undefined") {
      throw new AppwriteException('Missing required parameter: "bucketId"');
    }
    if (typeof fileId === "undefined") {
      throw new AppwriteException('Missing required parameter: "fileId"');
    }
    let path = "/storage/buckets/{bucketId}/files/{fileId}/view".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
    let payload = {};
    const uri = new URL(this.client.config.endpoint + path);
    payload["project"] = this.client.config.project;
    for (const [key, value] of Object.entries(Service.flatten(payload))) {
      uri.searchParams.append(key, value);
    }
    return uri;
  }
};
var Teams = class extends Service {
  list(search, limit, offset, cursor, cursorDirection, orderType) {
    return __awaiter(this, void 0, void 0, function* () {
      let path = "/teams";
      let payload = {};
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof limit !== "undefined") {
        payload["limit"] = limit;
      }
      if (typeof offset !== "undefined") {
        payload["offset"] = offset;
      }
      if (typeof cursor !== "undefined") {
        payload["cursor"] = cursor;
      }
      if (typeof cursorDirection !== "undefined") {
        payload["cursorDirection"] = cursorDirection;
      }
      if (typeof orderType !== "undefined") {
        payload["orderType"] = orderType;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  create(teamId, name, roles) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof teamId === "undefined") {
        throw new AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof name === "undefined") {
        throw new AppwriteException('Missing required parameter: "name"');
      }
      let path = "/teams";
      let payload = {};
      if (typeof teamId !== "undefined") {
        payload["teamId"] = teamId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof roles !== "undefined") {
        payload["roles"] = roles;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("post", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  get(teamId) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof teamId === "undefined") {
        throw new AppwriteException('Missing required parameter: "teamId"');
      }
      let path = "/teams/{teamId}".replace("{teamId}", teamId);
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  update(teamId, name) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof teamId === "undefined") {
        throw new AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof name === "undefined") {
        throw new AppwriteException('Missing required parameter: "name"');
      }
      let path = "/teams/{teamId}".replace("{teamId}", teamId);
      let payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("put", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  delete(teamId) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof teamId === "undefined") {
        throw new AppwriteException('Missing required parameter: "teamId"');
      }
      let path = "/teams/{teamId}".replace("{teamId}", teamId);
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("delete", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  getMemberships(teamId, search, limit, offset, cursor, cursorDirection, orderType) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof teamId === "undefined") {
        throw new AppwriteException('Missing required parameter: "teamId"');
      }
      let path = "/teams/{teamId}/memberships".replace("{teamId}", teamId);
      let payload = {};
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof limit !== "undefined") {
        payload["limit"] = limit;
      }
      if (typeof offset !== "undefined") {
        payload["offset"] = offset;
      }
      if (typeof cursor !== "undefined") {
        payload["cursor"] = cursor;
      }
      if (typeof cursorDirection !== "undefined") {
        payload["cursorDirection"] = cursorDirection;
      }
      if (typeof orderType !== "undefined") {
        payload["orderType"] = orderType;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  createMembership(teamId, email, roles, url, name) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof teamId === "undefined") {
        throw new AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof email === "undefined") {
        throw new AppwriteException('Missing required parameter: "email"');
      }
      if (typeof roles === "undefined") {
        throw new AppwriteException('Missing required parameter: "roles"');
      }
      if (typeof url === "undefined") {
        throw new AppwriteException('Missing required parameter: "url"');
      }
      let path = "/teams/{teamId}/memberships".replace("{teamId}", teamId);
      let payload = {};
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof roles !== "undefined") {
        payload["roles"] = roles;
      }
      if (typeof url !== "undefined") {
        payload["url"] = url;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("post", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  getMembership(teamId, membershipId) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof teamId === "undefined") {
        throw new AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof membershipId === "undefined") {
        throw new AppwriteException('Missing required parameter: "membershipId"');
      }
      let path = "/teams/{teamId}/memberships/{membershipId}".replace("{teamId}", teamId).replace("{membershipId}", membershipId);
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("get", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  updateMembershipRoles(teamId, membershipId, roles) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof teamId === "undefined") {
        throw new AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof membershipId === "undefined") {
        throw new AppwriteException('Missing required parameter: "membershipId"');
      }
      if (typeof roles === "undefined") {
        throw new AppwriteException('Missing required parameter: "roles"');
      }
      let path = "/teams/{teamId}/memberships/{membershipId}".replace("{teamId}", teamId).replace("{membershipId}", membershipId);
      let payload = {};
      if (typeof roles !== "undefined") {
        payload["roles"] = roles;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("patch", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  deleteMembership(teamId, membershipId) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof teamId === "undefined") {
        throw new AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof membershipId === "undefined") {
        throw new AppwriteException('Missing required parameter: "membershipId"');
      }
      let path = "/teams/{teamId}/memberships/{membershipId}".replace("{teamId}", teamId).replace("{membershipId}", membershipId);
      let payload = {};
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("delete", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
  updateMembershipStatus(teamId, membershipId, userId, secret) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof teamId === "undefined") {
        throw new AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof membershipId === "undefined") {
        throw new AppwriteException('Missing required parameter: "membershipId"');
      }
      if (typeof userId === "undefined") {
        throw new AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new AppwriteException('Missing required parameter: "secret"');
      }
      let path = "/teams/{teamId}/memberships/{membershipId}/status".replace("{teamId}", teamId).replace("{membershipId}", membershipId);
      let payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + path);
      return yield this.client.call("patch", uri, {
        "content-type": "application/json"
      }, payload);
    });
  }
};
export {
  Account,
  AppwriteException,
  Avatars,
  Client,
  Databases,
  Functions,
  Locale,
  Query,
  Storage,
  Teams
};
//# sourceMappingURL=appwrite.js.map
